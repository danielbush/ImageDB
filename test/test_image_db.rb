$M = false
require File.dirname(__FILE__) + '/test_helper.rb'

class TestImageDb < Test::Unit::TestCase

  Image = DLBImageUtils::ImageFile::Image

  include ITestUtils  # test_helper

  def setup
    ITestUtils.reset
    build_images
  end

  
  #--------------------------------------------------------------
  # Starting the db

  def test_01a
    db = ITestUtils.newdb
    assert(/image-db-tests/===db.root)
  end

  #--------------------------------------------------------------
  # Storing images

  def test_02a
    db = ITestUtils.newdb
    nm = File.join(test_data,'image-1.jpg')
    r = db.store(nm)
    assert File.exists?(r)
  end

  # Storing the same thing will cause an error
  # unless we apply force option...

  def test_02b
    db = ITestUtils.newdb
    nm = File.join(test_data,'image-1.jpg')
    r = db.store(nm)
    assert_raise ::RuntimeError do
      r = db.store(nm)
    end
    r = db.store(nm,:force => true)  # No errors this time.
  end

  # Store an image with an alternate name...

  def test_02c
    db = ITestUtils.newdb
    nm = File.join(test_data,'image-1.jpg')
    r = db.store(nm,:name => 'image-1a.jpg')
    #puts %x{file #{r}}
    assert_equal 'image-1a.jpg',File.basename(r)
  end

  # Store an image with force option will update sized images...

  def test_02d
    db = build
    n1 = db.fetch('image-1.jpg',:width => 101)
    n2 = db.fetch('image-1.jpg',:width => 102)
    assert File.exists?(n1)
    assert File.exists?(n2)
    nm = File.join(test_data,'image-2.jpg')
    r = db.store(nm,:name => 'image-1.jpg',:force => true)
    assert !File.exists?(n1)
    assert !File.exists?(n2)
  end


  #--------------------------------------------------------------
  # Fetching

  # Fetching sized image with rel_root

  def test_03c1
    db = build '/rel/root'
    nm = db.fetch('image-1.jpg')
    assert_equal File.join('/rel/root','originals','image-1.jpg'),nm
    nm = db.fetch('image-1.jpg',:width => 102 )
    assert_equal File.join('/rel/root','w','102','image-1.jpg'),nm
      # We had an error here.
  end

  # Fetching will not re-size an existing file...

  def test_03e
    db = build
    nm = db.fetch('image-1.jpg',:height => 102 ) # Autogenerate
    t1 = File.new(nm).mtime
    Kernel.sleep 1
    nm = db.fetch('image-1.jpg',:height => 102 ) # Not autogenerated
    t2 = File.new(nm).mtime
    assert_equal t1,t2
  end

  # Fetching with absolute overrides normal resolving...

  def test_03f
    rel_root = '/crazy/http/alias'
    db = build(rel_root)
    nm = db.fetch('image-1.jpg' )
    assert_equal File.join(rel_root,'originals','image-1.jpg'),nm
    nm = db.fetch('image-1.jpg',:absolute => true )
    assert_equal File.join(db.root,'originals','image-1.jpg'),nm
  end


  # Fetching nil returns nil unless not-found is set...
  #
  # Fetching nil might be one way to deliberately retrieve
  # a not-found image.  It also turns out to be useful
  # in acts as image file rails plugin when dealing with
  # a new image record that doesn't have a name.

  def test_03g
    rel_root = '/crazy/http/alias'
    db = build(rel_root)

    nm = db.fetch(nil)
    assert_nil nm

    nm = db.fetch(nil,:not_found => 'foo.jpg')
    assert /foo.jpg/===nm

    db.use_not_found = true
    db.not_found_image = 'bar.jpg'
    nm = db.fetch(nil)
    assert /bar.jpg/===nm
  end

  #--------------------------------------------------------------
  # Resolving images

  # Resolving with a specified root...

  def test_04a
    rel = '/crazy/http/alias'
    db = build rel
    nm = db.fetch('image-1.jpg')
    assert_equal File.join(rel,'originals','image-1.jpg'),nm
  end

  # Resolver uses actual root if one was not specified

  def test_04b
    db = build
    nm = db.fetch('image-1.jpg')
    assert_equal File.join(db.root,'originals','image-1.jpg'),nm
  end

  #--------------------------------------------------------------
  # Updating

  # Update a sized image will force resize

  def test_05a
    db = build
    nm = db.fetch 'image-1.jpg',:width => 102  # Autogenerate
    t1 = File.new(nm).mtime
    Kernel.sleep 1
    nm = db.update 'image-1.jpg',:width => 102  
    t2 = File.new(nm).mtime
    assert_not_equal t1,t2
  end

  # Update an original image, updates all sized images

  def test_05b
    db = build
    nm = db.fetch 'image-1.jpg',:width => 102  # Autogenerate
    t1 = File.new(nm).mtime
    nm2 = db.fetch 'image-1.jpg',:width => 103  # Autogenerate
    t2 = File.new(nm2).mtime
    Kernel.sleep 1
    db.update 'image-1.jpg' # Update everything.
    assert_not_equal t1,File.new(nm).mtime
    assert_not_equal t2,File.new(nm2).mtime
  end

  #--------------------------------------------------------------
  # Listing

  # List original images

  def test_06a
    db = build
    assert_equal 6,db.images.size
  end

  # Fetch info about an image...

  def test_06b
    db = build
    db.fetch('image-1.jpg',:width => 102)
    db.fetch('image-1.jpg',:width => 103)
    db.fetch('image-1.jpg',:width => 104)
    db.fetch('image-1.jpg',:height => 105)
    r = db.image('image-1.jpg')
    assert_equal 'image-1.jpg',r[:original]
  end

  # Search images
  #
  # Just use grep...

  def test_06c
    db = build
    db.images.grep(/image-1/)
  end

  # Globbing

  def test_06d
    db = build
    db.glob('image*')
  end


  #--------------------------------------------------------------
  # Deleting

  # Original and all sized versions are deleted...

  def test_07a
    db = build
    db.fetch('image-1.jpg',:width => 102)
    db.fetch('image-1.jpg',:width => 103)
    db.fetch('image-1.jpg',:width => 104)
    assert_equal 6,db.images.size
    assert_equal 3,db.image('image-1.jpg')[:widths].size
    r = db.delete('image-1.jpg')
    assert_equal 5,db.images.size # 5 originals left
    assert_equal nil,db.image('image-1.jpg')
  end

  # Delete a specific width or height...

  def test_07b
    db = build
    db.fetch('image-1.jpg',:width => 102)
    assert_equal 6,db.images.size
    assert_equal 1,db.image('image-1.jpg')[:widths].size
    r = db.delete('image-1.jpg',:width => 102)
    assert_equal 6,db.images.size  # Original still there
    assert_equal 0,db.image('image-1.jpg')[:widths].size
      # Sized version is not there
  end

  #--------------------------------------------------------------
  # Hooks

  # Create hook...

  # Storing a new original image...

  def test_08a
    db = ITestUtils.newdb
    db.hooks = hooks()

    nm = File.join(test_data,'image-1.jpg')
    r = db.store(nm)
    nm = File.join(test_data,'image-2.jpg')
    r = db.store(nm)
    assert_equal 2,db.hooks.count[:creates]
    assert_equal nil,db.hooks.params[:force]
    assert_equal File.join(db.root,'originals','image-2.jpg'),
                 db.hooks.params[:original]
  end

  # Should get called if fetch autogenerates an image...

  def test_08b
    db = ITestUtils.newdb
    db.hooks = hooks()

    nm = File.join(test_data,'image-1.jpg')
    r = db.store(nm)
    assert_equal 1,db.hooks.count[:creates]
    r = db.fetch('image-1.jpg',:width => 103)
    assert_equal 2,db.hooks.count[:creates]
    assert_equal true,db.hooks.params[:autogenerated]
    assert_equal 103,db.hooks.params[:width]
  end

  # Should be called if we update existing image

  def test_08c
    db = ITestUtils.newdb
    db.hooks = hooks()

    nm = File.join(test_data,'image-1.jpg')
    r = db.store(nm)
    r = db.fetch('image-1.jpg',:width => 103)
    r = db.update('image-1.jpg',:width => 103)
    # Should be 3 operations.
    assert_equal 3,db.hooks.count[:creates]
    assert_equal false,!!db.hooks.params[:autogenerated]
  end

  # Should be called if we force a new original over an existing

  def test_08d
    db = ITestUtils.newdb
    db.hooks = hooks()

    nm = File.join(test_data,'image-1.jpg')
    db.store(nm)
    assert_equal 1,db.hooks.count[:creates]
    assert_equal false,!!db.hooks.params[:force]
    db.store(nm,:force => true)
    assert_equal 2,db.hooks.count[:creates]
    assert_equal true,db.hooks.params[:force]
  end

  # Should be called if we update multiple items

  def test_08e
    db = ITestUtils.newdb
    nm = File.join(test_data,'image-1.jpg')
    nm = db.store(nm)
    db.fetch 'image-1.jpg',:width => 102
    db.fetch 'image-1.jpg',:width => 103
    db.fetch 'image-1.jpg',:width => 104
    db.hooks = hooks()
    db.update 'image-1.jpg'
    assert_equal 1,db.hooks.count[:creates]
    assert_equal File.join(nm),db.hooks.params[:original]
    assert_equal 3,db.hooks.params[:sized].size
    # 'update' only updates the sized images;
    # we update the original by calling 'store' with force.
  end


  # Delete hook...

  # Called multiple times when deleting original and all its
  # sized images...

  def test_09a
    db = ITestUtils.newdb
    nm = File.join(test_data,'image-1.jpg')
    r = db.store(nm)
    db.fetch 'image-1.jpg',:width => 102
    db.fetch 'image-1.jpg',:width => 103
    db.fetch 'image-1.jpg',:width => 104
    db.hooks = hooks()
    db.delete 'image-1.jpg'  # Delete image and all sized
    assert_equal 1,db.hooks.count[:deletes]
    assert_equal File.basename(r),db.hooks.params[:original]
    assert_equal 3,db.hooks.params[:sized].size
      # Returns array of 3 sized images that were deleted
  end

  # Called once if we delete a specific sized image...

  def test_09b
    db = ITestUtils.newdb
    nm = File.join(test_data,'image-1.jpg')
    db.store(nm)
    db.fetch 'image-1.jpg',:width => 102
    r = db.fetch('image-1.jpg',:width => 103)
    db.fetch 'image-1.jpg',:width => 104
    db.hooks = hooks()
    db.delete 'image-1.jpg',:width => 103
    assert_equal 1,db.hooks.count[:deletes]
    assert_equal r,db.hooks.params[:sized].first
    #assert_equal File.basename(r),db.hooks.params[:sized].first
    assert_equal 1,db.hooks.params[:sized].size
  end



  #--------------------------------------------------------------
  # Working with groups (recursing / sub-dbs)
  #
  # We want to test that we have recursed the db
  # successfully

  # Return empty array if no groups...

  def test_10a
    db = build
    assert_equal [],db.groups
  end

  # Storing an image against a group...

  def test_10b
    db = build
    nm = File.join(test_data,'image-1.jpg')
    db['group1'].store(nm)
    assert File.exists?(File.join(db.root,'groups',
                                  'group1','originals',
                                  'image-1.jpg'))
  end

  # Relative roots and groups...

  def test_10c
    rel_root = '/crazy/http/alias'
    db = build rel_root
    nm = File.join(test_data,'image-1.jpg')
    db['group1'].store(nm)
    r = db['group1'].fetch(nm)
    assert_equal File.join(rel_root,'groups',
                           'group1','originals',
                           'image-1.jpg'),r

    # Fetch absolute...
    r = db['group1'].fetch(nm, :absolute => true)
    assert_equal File.join(db['group1'].root,
                           'originals',
                           'image-1.jpg'),r
  end

  # Arbitrary nesting of groups...

  def test_10d
    db = build
    nm  = File.join(test_data,'image-1.jpg')
    nm2 = File.join(test_data,'image-2.jpg')
    db['group1']['group2'].store(nm)
    assert File.exists?(File.join(db.root,'groups',
                                  'group1','groups','group2',
                                  'originals','image-1.jpg'))
    assert !File.exists?(File.join(db.root,'groups',
                                  'group1','originals',
                                  'image-1.jpg'))
    db['group1'].store(nm)
    assert File.exists?(File.join(db.root,'groups',
                                  'group1','originals',
                                  'image-1.jpg'))
  end

  #--------------------------------------------------------------
  # Renaming

  # Rename an image over an existing one...
  # Existing should be deleted only if force is specified.

  def test_11a
    db = build
    assert_raise RuntimeError do
      db.rename 'image-1.jpg','image-2.jpg'
    end
    assert File.exists?(db.fetch('image-1.jpg' , :width => 30))
    assert File.exists?(db.fetch('image-2.jpg' , :width => 60))
    db.rename 'image-1.jpg','image-2.jpg',:force => true
    assert_nil db.fetch('image-1.jpg')
    assert File.exists?(db.absolute('image-2.jpg',
                                    :width => 30 ))
    assert_nil db.fetch('image-2.jpg',
                        :width => 60,
                        :resize => false)
  end

  #--------------------------------------------------------------
  # Not found image

  # db.not_found_image works...

  def test_12a
    db = build
    db.not_found_image = 'image-1.jpg'
    assert_equal 'image-1.jpg',db.not_found_image
    assert_equal 'image-1.jpg',db['group1'].not_found_image
    assert_equal 'image-1.jpg',db['group1']['group2'].not_found_image

    db['group1'].not_found_image = 'image-2.jpg'
    assert_equal 'image-2.jpg',db['group1'].not_found_image
  end

  # 'fetch' uses db.not_found_image correctly...

  # We can turn it on and off...

  def test_12b
    db = build
    db.not_found_image = 'image-1.jpg'
    r = db.fetch('foo.jpg')
    assert_nil r
    db.use_not_found = true
    r = db.fetch('foo.jpg')
    assert(/image-1.jpg/===r)
    db.use_not_found = false
    r = db.fetch('foo.jpg')
    assert_nil r
  end

  # Not found images are autogenerated if we specify a dimension...

  def test_12c
    db = build '/http/alias'
    db.not_found_image = 'image-1.jpg'
    db.use_not_found = true
    r = db.fetch('foo.jpg',:width => 61)
    assert(/.http.alias.w.61.image-1.jpg/===r)
    assert File.exists?(File.join(db.root,'w','61','image-1.jpg'))
#debugger
    r = db.fetch('foo.jpg',:width => 61, :absolute => true)
    assert(Regexp.new(db.root+'.w.61.image-1.jpg')===r)
  end

  # We can override the not found image at fetch-time...

  def test_12d
    db = build
    db.not_found_image = 'image-1.jpg'
    db.use_not_found = true
    r = db.fetch('foo.jpg' , :not_found => 'image-2.jpg')
    assert(/image-2.jpg/===r)
    r = db.fetch('foo.jpg')
    assert(/image-1.jpg/===r)
  end

  # We don't need to turn on use_not_found if we override

  def test_12d2
    db = build
    r = db.fetch('foo.jpg')
    assert_nil r
    r = db.fetch('foo.jpg' , :not_found => 'image-2.jpg')
    assert(/image-2.jpg/===r)
    r = db.fetch('foo.jpg' , :width => 61,
                 :not_found => 'image-2.jpg')
    assert(/w.61.image-2.jpg/===r)
    r = db.fetch('foo.jpg' , :width => 61)
    assert_nil r
  end


  # Fetch not found image if :resize is false (instead of autogenerating)
  # (original image exists)

  def test_12e
    db = build

    r = db.fetch('image-1.jpg',:height => 102,:resize => false)
    assert r.nil?

    db.not_found_image = 'image-2.jpg'
    db.use_not_found = true

    r = db.fetch('image-1.jpg',:height => 102,:resize => false)
    assert_equal r,(File.join(db.root,'h','102','image-2.jpg')).to_s
    #assert File.exists?(File.join(db.root,'h','102','image-2.jpg'))
# TODO: 27-Jun-2010
    assert(/image-2.jpg/===r)

    db.use_not_found = false
#debugger
    r = db.fetch('image-1.jpg',:height => 102,:resize => false)
    assert r.nil?
  end

  # not_found_image is nil...

  def test_12f
    db = build
    db.use_not_found = true
    db.not_found_image = nil
    r = db.fetch('foo.jpg')
    assert_nil r
    # We can still override it...
    r = db.fetch('foo.jpg' , :not_found => 'image-2.jpg')
    assert(/image-2.jpg/===r)
  end

  # fetch params[:not_found] is nil is respected ...

  def test_12g
    db = build
    db.use_not_found = true
    db.not_found_image = 'image-1.jpg'
    r = db.fetch('foo.jpg' , :not_found => nil)
    assert_nil r
    r = db.fetch('foo.jpg')
    assert(/image-1.jpg/===r)
  end

end
